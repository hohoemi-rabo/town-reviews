# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

**„Åæ„Å°Âè£„Ç≥„ÉüÂ∏≥** - A location-based community review platform for the Minami-Shinshu region (Iida/Shimoina area) in Japan.

### Core Concept
Digitally visualize local word-of-mouth culture by preserving "who told you about it" alongside location reviews on a map.

### Tech Stack
- Next.js 15.5.6
- React 19.1.0
- TypeScript (strict mode enabled)
- Tailwind CSS 3.4.17
- Turbopack (Next.js bundler)
- App Router architecture
- Supabase (PostgreSQL + Storage)
- Google Maps JavaScript API
- OpenAI API (GPT-4o-mini)

## Development Commands

```bash
# Start development server with Turbopack
npm run dev

# Build for production with Turbopack
npm run build

# Start production server
npm start

# Run linter
npm run lint

# Facility data management scripts
npm run fetch-facilities           # Legacy: Single facility fetch (use bulk-import instead)
npm run bulk-import:phase1          # Import Iida City facilities (~1,100 facilities)
npm run bulk-import:phase2          # Import major Shimoina towns (~2,400 facilities)
npm run bulk-import:phase3          # Import remaining Shimoina villages (~1,200 facilities)
npm run bulk-import:resume          # Resume interrupted bulk import from last checkpoint
npm run generate-kana               # Generate hiragana readings for all facilities (uses Kuroshiro)
npm run find-duplicates             # Detect duplicate facilities (by location/name)
npm run remove-duplicates           # Dry-run: Preview duplicate removal plan
npm run remove-duplicates:exec      # Execute duplicate removal (with 5s countdown)
npm run update-google-urls          # Auto-fetch google_maps_url for facilities (uses Google Places API)
npm run clear-places                # Clear all facility data (use with caution)
```

**Important**: Bulk import scripts support progress tracking and resume functionality. See `scripts/BULK_IMPORT_README.md` for details.

Development server runs on http://localhost:3000 (or available port if 3000 is in use)

## Project Structure

```
/src
  /app              - Next.js App Router (pages, layouts, API routes)
  /components       - Reusable React components
  /lib              - Utility functions and shared logic
  /types            - TypeScript type definitions
/docs               - Feature tickets and development documentation
  README.md         - Ticket index and priorities
  001-015_*.md      - Individual feature tickets with todos
/supabase
  /migrations       - Database migration files
REQUIREMENTS.md     - Full requirements specification
```

**Key conventions:**
- TypeScript path alias: `@/*` maps to `./src/*`
- All components default to Server Components unless `'use client'` directive
- Database types auto-generated: `src/types/database.types.ts`

## Configuration Files

- `tsconfig.json` - TypeScript strict mode, target ES2017
- `tailwind.config.ts` - Configured for `/src/**/*.{js,ts,jsx,tsx,mdx}`
  - Custom washi theme colors: beige, green, orange variants
  - Custom font: Zen Maru Gothic (via Google Fonts)
  - Custom shadow: `shadow-washi` for soft paper-like effect
- `next.config.ts` - Next.js configuration (minimal, will expand with CSP headers)
- `eslint.config.mjs` - ESLint with Next.js config
- `postcss.config.mjs` - PostCSS with Tailwind and Autoprefixer

### Environment Variables Required
```bash
NEXT_PUBLIC_SUPABASE_URL=
NEXT_PUBLIC_SUPABASE_ANON_KEY=
SUPABASE_SERVICE_ROLE_KEY=
NEXT_PUBLIC_GOOGLE_MAPS_API_KEY=      # Client-side (with referer restrictions)
GOOGLE_MAPS_SERVER_API_KEY=            # Server-side (no referer restrictions) - REQUIRED
OPENAI_API_KEY=
ADMIN_PASSWORD=                        # For admin panel authentication
```

**Important**: Two Google Maps API keys are required:
- `NEXT_PUBLIC_GOOGLE_MAPS_API_KEY` - For browser usage (Map display)
- `GOOGLE_MAPS_SERVER_API_KEY` - For API routes (Place Details, Find Place APIs)

## Backend Architecture

### Supabase Integration
This project uses Supabase for backend operations:
- **Database**: PostgreSQL with Row Level Security (RLS)
- **Storage**: Image uploads (recommendations-images bucket)
- **Real-time**: Reaction updates via Supabase Realtime
- Configuration: `.mcp.json` (contains API tokens - **NEVER commit this file**)
- `.mcp.json` is already in `.gitignore`

### Database Schema (Key Tables)
- `places` - Location information (3,034 facilities pre-registered from Google Places API after duplicate removal)
  - Key fields: `id`, `name`, `name_kana`, `address`, `area`, `category`, `lat`, `lng`, `place_id`, `google_maps_url`, `phone`, `is_verified`, `created_by`
  - **name_kana**: Hiragana readings auto-generated by Kuroshiro for search support (e.g., "‰∏âÊ≤≥ÂÆ∂" ‚Üí "„Åø„Åã„Çè„Åã")
  - **is_verified**: Admin approval flag (only `true` facilities appear in search)
  - **created_by**: 'admin' (manual), 'api' (Google Places API), 'user' (user request)
  - **Data coverage**: All of Iida City and Shimoina District (È£ØÁî∞Â∏Ç+‰∏ã‰ºäÈÇ£ÈÉ°ÂÖ®Âüü)
  - **CSV Import/Export**: Admin panel supports full data export/import with pagination (see Admin Panel section)
- `recommendations` - User reviews with source attribution and review categories
  - Key fields: `heard_from`, `heard_from_type`, `note_raw`, `note_formatted`, `review_category`, `images`, `tags`, `season`
  - `review_category`: '„Ç∞„É´„É°', 'ÊôØËâ≤', '‰ΩìÈ®ì', 'Áôí„Åó', '„Åù„ÅÆ‰ªñ' (with CHECK constraint)
  - `tags`: User-selected tags (27 options, max 7), array field - AI generation in Phase 2 as enhancement
  - `season`: User-selected season ('Êò•', 'Â§è', 'Áßã', 'ÂÜ¨', or null), optional - AI extraction in Phase 2 as enhancement
  - `is_editable_until`: 24-hour edit window timestamp
  - `author_ip_hash`: SHA-256 hashed IP (never store raw IPs)
- `reactions` - User reactions with columns: `id`, `recommendation_id`, `reaction_type`, `user_identifier`, `created_at`
  - **Important**: Use `user_identifier` (NOT `user_id`) for user tracking
  - Currently supports: `ittemiitai` (Ë°å„Å£„Å¶„Åø„Åü„ÅÑ)
- `facility_requests` - User-submitted facility addition requests (pending admin approval)
  - Key fields: `facility_name`, `address`, `area`, `category`, `requester_name`, `requester_email`, `status`, `admin_note`
  - **status**: 'pending', 'approved', 'rejected'
- `audit_logs` - Admin action tracking for security and accountability
  - Key fields: `action`, `target_type`, `target_id`, `details`, `admin_identifier`, `created_at`
  - **action**: 'create', 'update', 'delete', 'approve', 'reject'
  - **target_type**: 'recommendation', 'facility', 'facility_request'
  - Indexed by created_at, target_type, action for efficient querying
- `monthly_digests` - AI-generated monthly summaries (Phase 2)

### API Routes Structure
- `/api/facilities/search` - **POST**: Search facilities by keyword (supports hiragana/katakana/kanji)
  - Searches across: `name`, `name_kana`, `address`, `area`
  - Minimum 2 characters required
  - Returns only verified facilities (`is_verified = true`)
  - Supports filters: `area`, `category`, `limit`
- `/api/facility-requests` - **POST**: Submit facility addition request
  - Sends email notification to admin (rabo.hohoemi@gmail.com)
  - Required: `facility_name`
  - Optional: `address`, `area`, `category`, `requester_name`, `requester_email`
- `/api/parse-gmaps` - Parse Google Maps links (supports shortened URLs), extract Place ID, fetch place details
  - Supports `maps.app.goo.gl` shortened URLs
  - Falls back to Find Place from Text API if Place ID not found
  - **Note**: This API is deprecated in favor of facility search (Ticket 016)
- `/api/recommendations` - GET/POST: Manage recommendations
  - GET: Fetch recommendations with filters (`facility_id`, `tags`, `season`, `heard_from_types`, `categories`, `search`)
  - POST: Create new recommendation with validation (includes review_category, season, tags)
- `/api/tags` - GET: Fetch all tags sorted by usage frequency (5-minute cache)
- `/api/upload/image` - POST: Upload and convert images to WebP (max 1200px, quality 80%)
- `/api/upload/image/[path]` - DELETE: Remove images from storage
- `/api/reactions` - POST/DELETE: Manage reactions with optimistic updates
  - POST: Add reaction (duplicate check via `user_identifier`)
  - DELETE: Remove reaction
- `/api/recommendations/editable-list` - **GET**: Performance-optimized endpoint for edit permission checking
  - Returns array of all editable post IDs in single request
  - Prevents N+1 query problem when displaying multiple cards
  - Used by `useEditPermission` hook with global caching
- `/api/admin/auth` - POST/DELETE: Admin authentication (login/logout with session management)
- `/api/admin/recommendations/[id]` - GET/PATCH/DELETE: Admin-only recommendation operations (uses service role key)
- `/api/admin/recommendations/bulk-delete` - POST: Bulk delete recommendations (admin only)
- `/api/admin/facilities` - GET: Fetch facilities with search/filters (admin only, debounced 1 second)
- `/api/admin/facilities/[id]` - GET/PATCH/DELETE: Individual facility operations (admin only)
- `/api/admin/facility-requests` - GET: List facility addition requests with status filter
- `/api/admin/facility-requests/[id]` - PATCH: Approve/reject facility requests (creates place on approval)
- `/api/admin/stats` - GET: Fetch statistics data (posts, facilities, popular spots, tags, reactions)
- `/api/admin/audit-logs` - GET: Fetch audit logs with pagination
- `/api/admin/import-facilities` - **POST**: Bulk import facilities from CSV (admin only)
  - Accepts 14-column CSV format (same as export)
  - Supports both insert (new facilities) and update (existing facilities via ID)
  - Individual record processing with detailed error reporting
- `/api/admin/export-facilities` - **GET**: Export facilities to CSV with BOM for Excel compatibility
  - Supports pagination via `offset` and `limit` query parameters
  - Default limit: 1,000 records per batch
  - Includes BOM (Byte Order Mark) for Japanese character support in Excel
- `/api/ai/*` - AI features: tone conversion, tag generation (Phase 2)

## Project-Specific Conventions

### Design System
- **Theme**: Washi (Japanese paper) aesthetic with craft paper warmth
- **Colors**: Earth tones (Beige √ó Deep Green √ó Persimmon Orange)
- **Font**: Zen Maru Gothic (rounded, soft Japanese typeface)
- **Animations**: Soft, gentle movements with stamp-like effects

### Data Flow Patterns
1. **Post Creation** (Updated in Ticket 016):
   - **Step 1**: User searches facility by keyword (hiragana/katakana/kanji supported)
   - Real-time suggestions displayed (300ms debounce)
   - User selects facility from list OR requests new facility
   - **Step 2**: Review form with source selector, category selector, image upload
   - Images uploaded via `/api/upload/image` (compressed + WebP conversion)
   - Data saved to Supabase with cookie for 24h edit window
   - **Old flow (deprecated)**: Google Maps URL input ‚Üí Parse API ‚Üí Form
2. **Facility Search** (Ticket 016):
   - User types keyword (minimum 2 characters)
   - `generateSearchVariants()` creates hiragana/katakana variants
   - Search API queries: `name`, `name_kana`, `address`, `area` with ILIKE
   - Returns only verified facilities
   - If not found: User can request facility addition via modal
3. **Map Display**: Supabase ‚Üí Filter/Cluster ‚Üí Google Maps markers (color by category)
4. **Reactions**:
   - User clicks reaction button
   - **Optimistic Update**: UI updates immediately (count +1 or -1)
   - API call sent to `/api/reactions` (POST or DELETE)
   - On error: UI reverts to previous state
   - Supabase Realtime keeps all clients in sync
   - LocalStorage tracks user's reactions for duplicate prevention
5. **Image Processing**:
   - Client: browser-image-compression (max 1MB, 1920px)
   - Server: sharp (resize to 1200px, convert to WebP at 80% quality)

### Key Features
- **No authentication required** for posting (cookie-based edit window: 12h)
- **Source attribution**: Who told you about this place (ÂÆ∂Êóè, Âèã‰∫∫, ËøëÊâÄ„ÅÆ‰∫∫, etc.)
- **Review categories**: Manual selection from „Ç∞„É´„É°, ÊôØËâ≤, ‰ΩìÈ®ì, Áôí„Åó, „Åù„ÅÆ‰ªñ
  - Category badges displayed on review cards with color coding
- **Season selection**: Optional manual selection (Êò•, Â§è, Áßã, ÂÜ¨) with visual emoji buttons
- **Tag selection**: 24 predefined tags across 5 categories, max 3 per post (displays first 5 + "+N" badge on cards)
  - ÊñôÁêÜ„Ç∏„É£„É≥„É´ (6): ÂíåÈ£ü, Ê¥ãÈ£ü„Éª„Ç§„Çø„É™„Ç¢„É≥, ‰∏≠ËèØ, „Ç´„Éï„Çß„Éª„Çπ„Ç§„Éº„ÉÑ, „É©„Éº„É°„É≥„ÉªÈ∫∫È°û, ÁÑºËÇâ„ÉªÂ±ÖÈÖíÂ±ã ‚Üí Red color
  - Èõ∞Âõ≤Ê∞ó„ÉªÁâπÂæ¥ (7): Áµ∂ÊôØ, Á©¥Â†¥, ‰∫∫Ê∞ó, Èùô„Åã, Ë≥ë„ÇÑ„Åã, „É¨„Éà„É≠, SNSÊò†„Åà ‚Üí Blue color
  - Ë™∞„Å®Ë°å„Åè (6): ÂÆ∂ÊóèÂêë„Åë, Â≠êÈÄ£„ÇåOK, „Éá„Éº„ÉàÂêë„Åç, ‰∏Ä‰∫∫„Åß„ÇÇÊ•Ω„Åó„ÇÅ„Çã, Âèã‰∫∫„Å®, Âõ£‰ΩìOK ‚Üí Purple color
  - „Ç¢„ÇØ„Çª„Çπ„ÉªË®≠ÂÇô (2): ÈßêËªäÂ†¥„ÅÇ„Çä, „Éê„É™„Ç¢„Éï„É™„Éº ‚Üí Green color (ÈßÖËøë„ÉªËªäÂøÖÈ†à removed)
  - ÊôÇÈñìÂ∏Ø (3): Êúù„Åå„Åä„Åô„Åô„ÇÅ, Êòº„Åå„Åä„Åô„Åô„ÇÅ, Â§ú„Åå„Åä„Åô„Åô„ÇÅ ‚Üí Orange color
  - **Note**: ‰æ°Ê†ºÂ∏Ø„ÄÅÂú∞ÂüüÊÄß„Éª„Åù„ÅÆ‰ªñ„Ç´„ÉÜ„Ç¥„É™„Éº„ÅØÁèæÂú®„Ç≥„É°„É≥„Éà„Ç¢„Ç¶„ÉàÔºàÂ∞ÜÊù•ÁöÑ„Å´ËøΩÂä†Ê§úË®éÔºâ
- **Search & Filter**: Multiple filter options (category, season, tags, heard_from_types, keyword search)
- **Manual Refresh**: üîÑ Button to fetch latest posts from other users (no real-time updates)
- **Toast Notifications**: Custom toast system for success/error/info messages (replaces alert())
- **Confirmation Modals**: Custom modal dialogs for dangerous operations (replaces confirm())
- **Admin Panel**: Password-protected admin interface for comprehensive data management
  - Authentication with session cookies
  - Post editing/deletion (bypasses RLS with service role key)
  - Bulk operations support (post deletion, facility import/export)
  - **CSV Import/Export**:
    - Export all facilities with pagination support (handles 3,000+ records)
    - Import facilities from CSV (14-column format with BOM support)
    - Automatic BOM (Byte Order Mark) for Excel Japanese character compatibility
    - Individual record processing with detailed error reporting
- **Category-based pin colors**: È£≤È£ü=Orange, ‰ΩìÈ®ì=Blue, Ëá™ÁÑ∂=Green, Ê∏©Ê≥â=Brown
- **AI features** (Phase 2): Tone softening as enhancement (manual input remains primary)
- **Mobile-first**: Optimized for 60+ age users with accessibility focus

### Security Notes
- IP addresses are SHA-256 hashed, never stored raw
- Image uploads: Max 1 per post (reduced from 3), 5MB each, JPEG/PNG only
- Rate limiting on API routes (especially AI endpoints)
- CSP headers prevent XSS attacks (worker-src, script-src, etc.)
- Admin panel protected by environment variable password

## Important Build Notes

- All builds use Turbopack for faster compilation
- TypeScript strict mode enforced - all code must be type-safe
- Tailwind classes scoped to `/src/` directory only
- No test framework configured yet (add in Phase 2)
- Development server may use different ports (3001, 3002, 3003) if 3000 is occupied
- Environment variable changes require server restart to take effect

## Key Components and Utilities

### Components
- `Map/Map.tsx` - Google Maps with clustering, category-colored pins
  - **Important**: Uses singleton pattern for script loading to prevent duplicate API loads
  - **Note**: Current location feature is commented out (lines 38, 73-138, 208-211)
- `ReviewCard/*` - Card UI with optimized images, tags, reactions, source attribution, infinite scroll
- `Toast/ToastProvider.tsx` - Global toast notification system with auto-dismiss (3s)
  - Three types: success (green), error (red), info (blue)
  - Slide-in animation from right, click to dismiss
  - Usage: `const { showToast } = useToast(); showToast('Message', 'success')`
- `ConfirmModal/ConfirmModal.tsx` - Reusable confirmation modal for dangerous actions
  - Three types: danger (red), warning (orange), info (green)
  - Used for delete confirmations, bulk operations, CSV imports
- `PostModal/PostModal.tsx` - 2-step post creation (facility search ‚Üí form) **Updated in Ticket 016**
- `PostModal/FacilitySearchInput.tsx` - Facility search with real-time suggestions, keyboard navigation
- `PostModal/FacilityRequestModal.tsx` - Facility addition request form with email notification
- `PostModal/ImageUpload.tsx` - Drag & drop image upload with compression and preview
- `PostModal/SourceSelector.tsx` - Information source selection (6 presets + other)
- `PostModal/CategorySelector.tsx` - Review category selection (5 categories with emoji icons)
- `PostModal/SeasonSelector.tsx` - Season selection with emoji buttons (optional)
- `PostModal/TagSelector.tsx` - Tag selection with category accordion (26 tags across 5 categories, max 7, displays 5 + "+N")
- `Filter/*` - Filter components for recommendation filtering
  - `FilterPanel.tsx` - Desktop sidebar filter panel
  - `FilterBottomSheet.tsx` - Mobile bottom sheet filter
  - `CategoryFilter.tsx` - Review category filter (multiple selection)
  - `TagFilter.tsx` - Tag filter with frequency count
  - `SeasonFilter.tsx` - Season filter (single selection)
  - `SourceFilter.tsx` - Information source filter (multiple selection)
  - `FacilityFilter.tsx` - Facility filter (reuses FacilitySearchInput)
  - `ContentSearchInput.tsx` - Debounced keyword search input
- `Admin/*` - Admin panel components
  - `EditRecommendationModal.tsx` - Edit modal with all fields (reuses SeasonSelector and TagSelector)
  - `ApproveFacilityModal.tsx` - Modal for approving facility requests with manual data entry
  - `RejectFacilityModal.tsx` - Modal for rejecting facility requests with reason
  - `EditFacilityModal.tsx` - Modal for editing facility information
- `Reaction/ReactionButtons.tsx` - Reaction buttons with optimistic updates and Realtime sync (currently commented out in ReviewCard)
- `ReviewCard/ReviewTags.tsx` - Tag display component (shows max 5 tags + "+N" badge for remainder)

### Utilities
- `lib/google-maps.ts` - Map initialization, link parsing (supports shortened URLs), default settings
  - **Critical**: `loadGoogleMapsScript()` uses Promise caching and DOM checking to prevent multiple script loads
- `lib/text-utils.ts` - Text conversion utilities (hiragana ‚áî katakana, full-width ‚Üí half-width)
  - `generateSearchVariants()`: Creates search variants for facility search (e.g., "„Åø„Åã„Çè" ‚Üí ["„Åø„Åã„Çè", "„Éü„Ç´„ÉØ"])
- `lib/formatters.ts` - Time formatting, icons (heard_from, category), tag colors, review category emoji/colors
- `lib/image-compression.ts` - Client-side image validation and compression
- `lib/supabase/client.ts` - Browser-side Supabase client
- `lib/supabase/server.ts` - Server-side Supabase client (with Next.js 15 async cookies)
- `lib/supabase/admin.ts` - **New**: Admin-only Supabase client using service role key (bypasses RLS)
  - ‚ö†Ô∏è **Critical**: Only use in server-side admin API routes, never expose to client
- `lib/audit-log.ts` - **New**: Audit log utility for tracking admin actions
  - `createAuditLog()`: Records admin operations to audit_logs table
  - Supports actions: create, update, delete, approve, reject
  - Target types: recommendation, facility, facility_request
- `lib/local-storage.ts` - LocalStorage management for user reactions (UUID-based tracking)
- `styles/map-styles.ts` - Custom washi-themed Google Maps styles

### Scripts
- `scripts/fetch-facilities.ts` - Legacy single facility fetch (replaced by bulk import)
- `scripts/fetch-facilities-bulk.ts` - **Primary**: Bulk facility import with progress tracking (4,670 facilities)
  - Supports 3 phases: Phase 1 (Iida City), Phase 2 (Major towns), Phase 3 (Villages)
  - Resume functionality via `bulk-import-progress.json`
  - Duplicate detection via `place_id`
  - Automatic retry with exponential backoff
- `scripts/generate-kana.ts` - Auto-generate hiragana readings using Kuroshiro + Kuromoji
  - Supports pagination for large datasets (1,000 records per batch)
  - Processes only facilities without existing `name_kana`
- `scripts/find-duplicates.ts` - **New**: Detect duplicate facilities without using Google Maps API
  - Three detection methods: exact lat/lng match, name+address match, proximity (100m radius)
  - Displays grouped duplicates with keep/delete recommendations
  - Read-only analysis tool (does not modify database)
- `scripts/remove-duplicates.ts` - **New**: Remove duplicate facilities with safety features
  - Two modes: dry-run (default) and execute (`--execute` flag)
  - Automatic CSV backup before deletion (`scripts/output/backup_before_dedup_*.csv`)
  - Keeps newest record (by `created_at`), deletes older duplicates
  - Rate limiting: 50ms delay between deletions
  - 5-second countdown before execution with Ctrl+C abort
- `scripts/update-google-urls.ts` - **New**: Auto-fetch google_maps_url using Google Places API
  - Targets facilities with null google_maps_url
  - Uses name + address to search via Find Place from Text API
  - Fetches Place Details API for google_maps_url
  - Progress tracking and resume capability
  - Rate limiting: 100ms delay between API calls
- `scripts/count-places.ts` - Display facility statistics (total, by area, by registration source)
- `scripts/clear-places.ts` - Clear all facility data (requires confirmation)
- `scripts/delete-place.ts` - Delete specific facility by ID or Place ID
- `scripts/cleanup-*.ts` - Utility scripts for data cleanup

### Hooks
- `hooks/useUserId.ts` - Generate and persist anonymous user UUID in LocalStorage
- `hooks/useReactions.ts` - Fetch reaction counts and subscribe to Realtime updates
  - Exports `incrementCount` and `decrementCount` for optimistic updates
- `hooks/useFilter.ts` - Filter state management with URL synchronization
  - Manages facility_id, tags, season, heardFromTypes, categories, search
  - Provides updateFilters, clearFilters, activeFilterCount
- `hooks/useDebounce.ts` - Generic debounce hook (500ms default)
- `hooks/useEditPermission.ts` - **Performance-optimized**: Check edit permissions with global caching
  - Uses singleton pattern to prevent N+1 queries (1 API call instead of N calls)
  - Module-level cache shared across all component instances
  - Fetches all editable IDs in single request via `/api/recommendations/editable-list`
  - Exports `addEditableId` and `removeEditableId` for cache updates

### Important Patterns
- Main page (`app/page.tsx`) has map/list toggle view with real-time database fetching
- All marker icons use `google.maps.SymbolPath.CIRCLE` with category-specific colors
- Review cards use Next.js Image with blur placeholder and loading animation
- Image upload: Client compression ‚Üí Server WebP conversion ‚Üí Supabase Storage
- Cookie-based edit tracking: 24h window stored in `editable_posts` cookie
- **Optimistic Updates**: UI updates immediately before API response, with rollback on error
- **Supabase Realtime**: Subscribe to INSERT/DELETE events for live updates across clients

## Critical Architectural Patterns

### Optimistic Updates Pattern
Used in reaction buttons to provide instant feedback:

```typescript
// In useReactions hook
const incrementCount = (reactionType) => {
  setCounts((prev) => ({ ...prev, [reactionType]: prev[reactionType] + 1 }))
}

// In ReactionButtons component
const handleReactionClick = async (reactionType) => {
  // 1. Update UI immediately (optimistic)
  incrementCount(reactionType)
  addUserReaction(recommendationId, reactionType)

  // 2. Send API request
  const response = await fetch('/api/reactions', { method: 'POST', ... })

  // 3. Rollback on error
  if (!response.ok) {
    decrementCount(reactionType)
    removeUserReaction(recommendationId, reactionType)
  }
}
```

### Google Maps Script Loading (Singleton Pattern)
Prevents "multiple API loads" error:

```typescript
let loadingPromise: Promise<void> | null = null

export function loadGoogleMapsScript(): Promise<void> {
  // Return if already loaded
  if (typeof window.google !== 'undefined') return Promise.resolve()

  // Return existing promise if loading
  if (loadingPromise) return loadingPromise

  // Check for existing script in DOM
  const existingScript = document.querySelector(`script[src*="maps.googleapis.com"]`)
  if (existingScript) { /* handle existing script */ }

  // Create new script
  loadingPromise = new Promise((resolve, reject) => {
    const script = document.createElement('script')
    script.onload = () => { loadingPromise = null; resolve() }
    document.head.appendChild(script)
  })

  return loadingPromise
}
```

### Bulk Facility Import Workflow
Critical process for importing facility data from Google Places API:

**Phase Structure:**
```bash
# Phase 1: Iida City (È£ØÁî∞Â∏Ç) - ~1,100 facilities
npm run bulk-import:phase1

# Phase 2: Major Towns (ÊùæÂ∑ùÁî∫, È´òÊ£ÆÁî∫, etc.) - ~2,400 facilities
npm run bulk-import:phase2

# Phase 3: Villages (ÈòøÊô∫Êùë, Ë±ä‰∏òÊùë, etc.) - ~1,200 facilities
npm run bulk-import:phase3

# Resume from last checkpoint if interrupted
npm run bulk-import:resume
```

**Important Implementation Details:**
- Progress saved to `scripts/bulk-import-progress.json` after each successful facility
- Duplicate prevention via `place_id` (skips if already exists)
- Rate limiting: 100ms delay between API calls to avoid quota issues
- Retry logic: 3 attempts with exponential backoff (1s, 2s, 4s)
- **Critical**: Two Google Maps API keys required (client + server)
- After import completion, run `npm run generate-kana` to add hiragana readings

**Troubleshooting:**
- If import fails: Check `bulk-import-progress.json` for last successful facility
- If quota exceeded: Wait 24h or use `--resume` flag to continue
- If duplicates appear: Script automatically skips via `place_id` check

### Common Pitfalls and Solutions

1. **Database Column Names**
   - ‚ùå Wrong: Using `user_id` in reactions table
   - ‚úÖ Correct: Use `user_identifier` (actual column name)
   - Always check `src/types/database.types.ts` for accurate schema

2. **Supabase JOIN Results**
   - ‚ùå Wrong: Assuming joined data is a single object
   - ‚úÖ Correct: Supabase returns joined data as arrays, transform to single object:
   ```typescript
   const transformedData = data.map((item) => ({
     ...item,
     places: Array.isArray(item.places) ? item.places[0] : null
   }))
   ```

3. **React Hooks Dependencies**
   - ‚ùå Wrong: Using `observerTarget.current` directly in cleanup
   - ‚úÖ Correct: Store ref in variable before use:
   ```typescript
   useEffect(() => {
     const currentTarget = observerTarget.current
     // ... use currentTarget in observer and cleanup
     return () => { observer.unobserve(currentTarget) }
   }, [dependencies])
   ```

4. **Type Safety with Supabase Queries**
   - Export shared types from components for reuse:
   ```typescript
   // In ReviewList.tsx
   export type ExtendedRecommendation = Tables<'recommendations'> & {
     places: Tables<'places'> | null
   }

   // In page.tsx
   import { type ExtendedRecommendation } from '@/components/ReviewCard/ReviewList'
   ```

5. **Unique Constraint Fields with Empty Values**
   - ‚ùå Wrong: Setting empty string for unique constraint fields
   ```typescript
   place_id: placeData.place_id || '' // Causes duplicate key violation
   ```
   - ‚úÖ Correct: Use `null` for empty unique constraint fields
   ```typescript
   place_id: placeData.place_id || null // Allows multiple NULL values
   ```
   - Important: SQL allows multiple `NULL` values in unique constraint fields, but not multiple empty strings

6. **RLS Policies with SELECT After INSERT**
   - ‚ùå Wrong: Only INSERT policy when using `.insert().select()`
   - ‚úÖ Correct: Both INSERT and SELECT policies required
   ```sql
   -- Need both policies for .insert().select().single() pattern
   CREATE POLICY "Allow insert" ON table FOR INSERT TO anon WITH CHECK (true);
   CREATE POLICY "Allow select" ON table FOR SELECT TO anon USING (true);
   ```

7. **CSV Export with Japanese Characters**
   - ‚ùå Wrong: Direct CSV export causes Excel garbled text
   - ‚úÖ Correct: Add BOM (Byte Order Mark) for Excel UTF-8 recognition
   ```typescript
   const bom = '\uFEFF'
   const blob = new Blob([bom + csv], { type: 'text/csv;charset=utf-8;' })
   ```

8. **Supabase Query Pagination for Large Datasets**
   - ‚ùå Wrong: Fetching all records without pagination (Supabase defaults to 1,000 limit)
   ```typescript
   const response = await fetch(`${SUPABASE_URL}/rest/v1/places?select=*`)
   const facilities = await response.json() // Only gets first 1,000
   ```
   - ‚úÖ Correct: Use offset/limit pagination to fetch all records
   ```typescript
   const facilities = []
   let offset = 0
   const limit = 1000

   while (true) {
     const response = await fetch(
       `${SUPABASE_URL}/rest/v1/places?select=*&limit=${limit}&offset=${offset}`
     )
     const batch = await response.json()
     facilities.push(...batch)

     if (batch.length < limit) break // No more records
     offset += limit
   }
   ```

9. **Duplicate Facility Data Management**
   - Problem: Bulk import executed multiple times can create duplicates with different IDs
   - Solution: Use duplicate detection and removal scripts
   ```bash
   # Step 1: Detect duplicates (read-only)
   npm run find-duplicates

   # Step 2: Preview removal plan (dry-run)
   npm run remove-duplicates

   # Step 3: Execute removal (after confirmation)
   npm run remove-duplicates:exec
   ```
   - **Important**: Always run dry-run first to verify deletion plan
   - Backup CSV is automatically created in `scripts/output/` before deletion
   - Detection criteria:
     - Exact lat/lng match (Á∑ØÂ∫¶ÁµåÂ∫¶ÂÆåÂÖ®‰∏ÄËá¥)
     - Name + Address match (ÊñΩË®≠ÂêçÔºã‰ΩèÊâÄ‰∏ÄËá¥)
   - Keeps newest record (by `created_at`), deletes older ones

10. **Google Maps API Configuration for Production Deployment**
   - Problem: `RefererNotAllowedMapError` when deploying to Vercel
   - **Root Cause**: API key not configured to allow production domain
   - Solution: Configure HTTP Referrer restrictions in Google Cloud Console

   **Steps to fix:**
   1. Go to Google Cloud Console ‚Üí APIs & Services ‚Üí Credentials
   2. Find the API key matching `NEXT_PUBLIC_GOOGLE_MAPS_API_KEY` (client-side key)
   3. Click on the key to edit
   4. **Application restrictions**: Select üîò **HTTP referrers (web sites)**
   5. **Website restrictions**: Add the following:
      ```
      http://localhost:3000/*
      https://localhost:3000/*
      https://your-domain.vercel.app/*
      ```
   6. **API restrictions**: Select üîò **Restrict key** and enable:
      - ‚úÖ Maps JavaScript API
      - ‚úÖ Places API
   7. Click **Save**
   8. Wait 2-5 minutes for changes to propagate
   9. Clear browser cache and reload

   **Important**: Two API keys are used in this project:
   - `NEXT_PUBLIC_GOOGLE_MAPS_API_KEY` - Client-side (needs HTTP referrer restrictions)
   - `GOOGLE_MAPS_SERVER_API_KEY` - Server-side (needs IP address restrictions or none)

   **Security Note**: After deployment, verify both keys in Vercel Environment Variables match the keys in Google Cloud Console

## Development Workflow

### Feature Tickets and Todo Management
Development is organized into feature tickets in `/docs`:
- View all tickets and priorities in `/docs/README.md`
- Each ticket follows format: `{number}_{feature_name}.md`
- Tickets include: overview, priority, time estimate, phase, specs, tasks, files, completion criteria

### Ticket Overlap Resolution
**Important**: Tickets 008, 009, and 016 had overlapping functionality that has been resolved:
- **Ticket 016**: Facility search for post creation (completed Phase 1-3)
- **Ticket 008**: Review filtering (reuses Ticket 016's facility search component)
- **Ticket 009**: Admin panel (integrates Ticket 016 Phase 4 as its Phase 3)

When implementing these tickets, always check the "ÂÇôËÄÉ" (Remarks) section for integration notes.

### Todo Format
```markdown
- [ ] Incomplete task
- [√ó] Completed task
```
**Critical**: Always update `- [ ]` to `- [√ó]` when completing tasks

### Development Process
1. Check `/docs/README.md` for ticket priorities (üî¥ Critical, üü° High, üü¢ Medium)
2. Open relevant ticket for detailed specs and implementation tasks
3. Implement features following the ticket's task list
4. Mark completed tasks with `- [√ó]`
5. Verify all completion criteria before marking ticket as done

### Phase Priority
- **Phase 1 (MVP)**: Tickets 001-009 - Core functionality for initial release
- **Phase 2 (Beta)**: Tickets 010-012 - AI features and optimization
- **Continuous**: Tickets 013-015 - Security, accessibility, legal compliance

### Current Implementation Status
**Phase 1 - MVP (Progress: 9/9 completed - 100%)** ‚úÖ **COMPLETED**

**Note**: All Phase 1 tickets have been successfully completed. The MVP is ready for deployment.
- ‚úÖ **Ticket 001**: Project setup with Next.js 15, Supabase, Google Maps
- ‚úÖ **Ticket 002**: Database schema with 4 tables + RLS policies
- ‚úÖ **Ticket 003**: Google Maps display with clustering, current location, category pins
- ‚úÖ **Ticket 004**: Review card UI with washi design, infinite scroll, image optimization
- ‚úÖ **Ticket 005**: Post modal with facility search, source selector, category selector, image upload
  - **Enhanced**: Added season selection (Êò•, Â§è, Áßã, ÂÜ¨) with emoji buttons
  - **Enhanced**: Added tag selection (26 predefined tags across 5 categories, max 7 per post)
  - **Enhanced**: Tag display on cards shows first 5 tags + "+N" badge for remainder
  - Review category feature (manual selection) integrated
  - Database: `review_category`, `season`, `tags` columns with data validation
  - UI: CategorySelector, SeasonSelector, TagSelector, ReviewTags components
  - **Note**: "„Åù„ÅÆ‰ªñ" input field temporarily commented out (may be re-enabled)
- ‚úÖ **Ticket 006**: Image optimization with WebP conversion, blur placeholders, deletion API
- ‚úÖ **Ticket 007**: Reaction feature (üëç Ë°å„Å£„Å¶„Åø„Åü„ÅÑ button) with optimistic updates and Realtime sync
  - **Note**: Currently commented out in ReviewCard.tsx (may be re-enabled based on user feedback)
- ‚úÖ **Ticket 008**: Search & filter (category, tags, season, heard_from_types, keyword search)
  - Desktop: FilterPanel sidebar with all filter options
  - Mobile: FilterBottomSheet with responsive design
  - URL state synchronization for shareable filtered views
  - Debounced keyword search (500ms) for recommendation content
  - Filter components: CategoryFilter, TagFilter, SeasonFilter, SourceFilter, FacilityFilter, ContentSearchInput
  - Real-time filter count display and clear filters functionality
- ‚úÖ **Ticket 009**: Admin panel (Phase 1-4 completed) ‚úÖ **COMPLETED**
  - **Phase 1**: Authentication & Foundation ‚úÖ
    - Password-based authentication with session cookies
    - Middleware protection for all `/admin/*` routes
    - Admin layout with sidebar navigation
    - Dashboard with statistics cards and quick actions
  - **Phase 2**: Post Management ‚úÖ
    - Post list with pagination (20 items/page)
    - Search functionality for post content, facility name, author name
    - Bulk selection and deletion
    - Individual edit and delete operations with 12-hour edit window
    - EditRecommendationModal with all fields editable (reuses SeasonSelector, TagSelector with max 7 tags)
    - Badge display for category, season, and tags
    - **Critical Fix**: Admin operations use service role key to bypass RLS after Cookie authentication
    - **Critical Fix**: Optimistic updates for smooth UX without page reload
  - **Phase 3**: Facility Management ‚úÖ
    - Facility addition request management (list, approve, reject)
    - Status filters (all, pending, approved, rejected)
    - Facility data management (CRUD operations)
    - Search with 1-second debounce, area/category filters
    - CSV export with BOM for Excel compatibility
    - ApproveFacilityModal, RejectFacilityModal, EditFacilityModal components
    - **Critical Fixes**:
      - RLS policies for `facility_requests` (INSERT + SELECT required)
      - `place_id` NULL constraint removal (allows manual facility addition)
      - Empty string ‚Üí NULL for unique constraint fields
  - **Phase 4**: Statistics & Audit Logs ‚úÖ
    - Statistics dashboard with real-time data
    - Recharts integration (pie charts, bar charts)
    - Review category breakdown, facility distribution by area/category
    - Popular spots TOP10, popular tags TOP10
    - Audit logs table with action tracking (create/update/delete/approve/reject)
    - Audit log utility function for easy logging
    - Audit logs display page with pagination

**Phase 1.5 - UX Improvement (Specification Change)** ‚úÖ **COMPLETED**
- ‚úÖ **Ticket 016**: Facility database pre-registration & search function ‚úÖ **FULLY COMPLETED**
  - **Background**: Google Maps URL input is too difficult for elderly users
  - **Solution**: Pre-registered 4,670 facilities covering entire Iida/Shimoina region
  - **Changes**: Complete removal of Google Maps URL input flow
  - **New flow**: Facility search (hiragana/katakana/kanji) ‚Üí Select ‚Üí Review form
  - **Facility request**: Simple form with email notification to admin (rabo.hohoemi@gmail.com)
  - **Phase 1**: Database schema, search API, facility request API ‚úÖ
  - **Phase 2**: FacilitySearchInput, FacilityRequestModal, PostModal refactor, hiragana search ‚úÖ
  - **Phase 3**: Google Places API bulk import (4,670‚Üí3,034 facilities after dedup), CSV import/export ‚úÖ
    - Initial import: 4,670 facilities (Iida City + Shimoina District)
    - Duplicate removal: 1,636 duplicates removed (phase 1 executed twice)
    - Final count: 3,034 unique facilities
    - All facilities have hiragana readings (name_kana) via Kuroshiro
    - Admin panel CSV import/export functionality with pagination support
  - **Phase 4**: Admin panel expansion ‚úÖ (integrated into Ticket 009 Phase 3)
  - **Post-Phase Maintenance**: Duplicate detection and removal scripts ‚úÖ
    - `find-duplicates.ts`: Detect duplicates by location/name without API
    - `remove-duplicates.ts`: Safe removal with dry-run mode and automatic backup

## Next.js App Router Best Practices

### Server Components vs Client Components

**Default: Use Server Components**
- All components in `/src/app/` are Server Components by default
- Server Components can be async and directly fetch data
- Keep components as Server Components unless you need:
  - Browser APIs (useState, useEffect, event handlers)
  - User interactivity
  - Custom hooks that use React hooks

**Client Components**
- Add `'use client'` directive at the top of the file
- Use for interactive UI elements only
- Keep Client Components small and deep in the component tree
- Pass data from Server Components to Client Components via props

```tsx
// Server Component (default) - can fetch data
export default async function Page() {
  const data = await fetch('https://api.example.com/data')
  const posts = await data.json()

  return <ClientButton posts={posts} />
}

// Client Component - receives data as props
'use client'
export default function ClientButton({ posts }) {
  const [count, setCount] = useState(0)
  return <button onClick={() => setCount(count + 1)}>{posts.length}</button>
}
```

### Data Fetching Strategies

**1. Server-Side Fetch (Recommended for most cases)**
```tsx
// Static data (cached until manually invalidated)
const data = await fetch('https://...', { cache: 'force-cache' }) // default

// Dynamic data (refetched on every request)
const data = await fetch('https://...', { cache: 'no-store' })

// Revalidated data (ISR - cached with time-based revalidation)
const data = await fetch('https://...', { next: { revalidate: 10 } }) // 10 seconds
```

**2. Database Queries in Server Components**
```tsx
import { db, posts } from '@/lib/db'

export default async function Page() {
  const allPosts = await db.select().from(posts)
  return <ul>{allPosts.map(post => <li key={post.id}>{post.title}</li>)}</ul>
}
```

**3. Client-Side Fetch (use SWR or React Query)**
```tsx
'use client'
import useSWR from 'swr'

export default function Profile() {
  const { data, error, isLoading } = useSWR('/api/user', fetcher)
  if (isLoading) return <div>Loading...</div>
  if (error) return <div>Error</div>
  return <div>{data.name}</div>
}
```

### Caching and Performance

**Fetch Cache Options:**
- `cache: 'force-cache'` - Cache until manually invalidated (default, like getStaticProps)
- `cache: 'no-store'` - Never cache, always fetch fresh (like getServerSideProps)
- `next: { revalidate: 60 }` - Cache with time-based revalidation (ISR)

**React Cache for Deduplication:**
```tsx
import { cache } from 'react'
import 'server-only'

export const getItem = cache(async (id: string) => {
  const res = await fetch(`https://api.example.com/item/${id}`)
  return res.json()
})
```

### Loading States and Suspense

Use React Suspense for streaming and loading states:

```tsx
import { Suspense } from 'react'

export default async function Page() {
  return (
    <div>
      <h1>My Page</h1>
      <Suspense fallback={<div>Loading...</div>}>
        <SlowComponent />
      </Suspense>
    </div>
  )
}

async function SlowComponent() {
  const data = await fetchSlowData()
  return <div>{data}</div>
}
```

### Environment Variables

**Server-only variables:**
- Can be used directly in Server Components
- Never exposed to the client
- Store API keys, database credentials here

```tsx
// Server Component - ‚úÖ Safe
export async function getData() {
  const res = await fetch('https://api.example.com/data', {
    headers: { authorization: process.env.API_KEY }
  })
  return res.json()
}
```

**Client-side variables:**
- Must be prefixed with `NEXT_PUBLIC_`
- Exposed to the browser
- Never store secrets here

### Sequential vs Parallel Data Fetching

**Sequential (waterfall - avoid if possible):**
```tsx
const artist = await getArtist(id)
const albums = await getAlbums(artist.id) // Waits for artist first
```

**Parallel (better performance):**
```tsx
const [artist, albums] = await Promise.all([
  getArtist(id),
  getAlbums(id)
])
```

**With Suspense (recommended for independent data):**
```tsx
<Suspense fallback={<ArtistSkeleton />}>
  <Artist id={id} />
</Suspense>
<Suspense fallback={<AlbumsSkeleton />}>
  <Albums id={id} />
</Suspense>
```

### Routing and Navigation

**File-based routing:**
- `app/page.tsx` ‚Üí `/`
- `app/about/page.tsx` ‚Üí `/about`
- `app/blog/[slug]/page.tsx` ‚Üí `/blog/:slug`
- `app/shop/[...slug]/page.tsx` ‚Üí `/shop/*` (catch-all)

**Navigation hooks (Client Components only):**
```tsx
'use client'
import { useRouter, usePathname, useSearchParams } from 'next/navigation'

export default function Component() {
  const router = useRouter()           // For programmatic navigation
  const pathname = usePathname()       // Current path
  const searchParams = useSearchParams() // Query parameters
}
```

### Layout and Template Best Practices

**Layouts:**
- Shared UI across multiple pages
- Preserve state across navigation
- Can fetch data like pages
- Nest layouts for section-specific UI

```tsx
// app/layout.tsx - Root layout
export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}
```

### Type Safety

**Async params and searchParams:**
```tsx
// Next.js 15+ - params and searchParams are Promises
export default async function Page({
  params,
  searchParams,
}: {
  params: Promise<{ slug: string }>
  searchParams: Promise<{ query: string }>
}) {
  const { slug } = await params
  const { query } = await searchParams
  // ...
}
```

### Common Patterns to Avoid

‚ùå **Don't use async Client Components:**
```tsx
'use client'
export default async function ClientComponent() {} // ERROR
```

‚úÖ **Instead, fetch in parent Server Component or use SWR:**
```tsx
// Server Component
export default async function Page() {
  const data = await fetchData()
  return <ClientComponent data={data} />
}
```

‚ùå **Don't import Server Components into Client Components:**
```tsx
'use client'
import ServerComponent from './server-component' // ERROR
```

‚úÖ **Pass Server Components as children:**
```tsx
<ClientComponent>
  <ServerComponent />
</ClientComponent>
```

### Next.js 15 Specific Issues

**useSearchParams() Requires Suspense Boundary:**
- Next.js 15 enforces Suspense boundaries for `useSearchParams()` to prevent build errors
- ‚ùå Wrong: Using `useSearchParams()` directly in page without Suspense
- ‚úÖ Correct: Wrap Client Components using `useSearchParams()` in Suspense

```tsx
// app/page.tsx - Server Component
import { Suspense } from 'react'
import HomeClient from './HomeClient'

export default function Home() {
  return (
    <Suspense fallback={<LoadingFallback />}>
      <HomeClient />
    </Suspense>
  )
}

// HomeClient.tsx - Client Component with useSearchParams
'use client'
import { useSearchParams } from 'next/navigation'

export default function HomeClient() {
  const searchParams = useSearchParams()
  // ... component logic
}
```

**Missing Type Properties from Generated Types:**
- ‚ùå Wrong: Assuming all database columns are in `database.types.ts`
- ‚úÖ Correct: Extend generated types for additional properties
```typescript
// Some properties may be missing from generated types
type Facility = Tables<'places'> & { name_kana?: string | null }
```

**Tables Not in Generated Types (e.g., audit_logs):**
- ‚ùå Wrong: Using table name directly with strict types
- ‚úÖ Correct: Use type assertion with eslint-disable for tables not in schema
```typescript
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const { data } = await (supabase as any).from('audit_logs').select('*')
```

11. **Admin Operations and RLS Bypass**
   - Problem: Edit/delete operations fail due to RLS policies blocking anonymous users
   - **Root Cause**: Using regular `createClient()` which respects RLS policies
   - Solution: Use `createAdminClient()` in admin API routes after Cookie authentication

   **Pattern:**
   ```typescript
   // In /api/admin/recommendations/[id]/route.ts (PATCH and DELETE)

   // 1. Verify Cookie authentication first
   const cookieStore = await cookies()
   const editablePosts = cookieStore.get('editable_posts')?.value

   if (!editablePosts) {
     return NextResponse.json({ error: 'Á∑®ÈõÜÊ®©Èôê„Åå„ÅÇ„Çä„Åæ„Åõ„Çì' }, { status: 403 })
   }

   // 2. Check edit window expiration
   const now = new Date()
   const until = new Date(post.until)
   if (now > until) {
     return NextResponse.json({ error: 'Á∑®ÈõÜÊúüÈôêÔºà12ÊôÇÈñìÔºâ„ÇíÈÅé„Åé„Å¶„ÅÑ„Åæ„Åô' }, { status: 403 })
   }

   // 3. Use admin client to bypass RLS AFTER authentication
   const supabase = createAdminClient()
   const { data, error } = await supabase
     .from('recommendations')
     .update({ ... })
     .eq('id', id)
   ```

   **Important**: Only use `createAdminClient()` in server-side API routes, never expose to client

12. **Optimistic Updates and Skip Flags**
   - Problem: New posts don't appear immediately, or disappear after useEffect refetch
   - **Root Cause**: useEffect refetches and overwrites optimistic updates
   - Solution: Use skip flag pattern to prevent useEffect after optimistic update

   **Pattern:**
   ```typescript
   // In HomeClient.tsx or ReviewList.tsx
   const [skipNextFetch, setSkipNextFetch] = useState(false)

   useEffect(() => {
     // Skip this fetch if we just added/updated data optimistically
     if (skipNextFetch) {
       setSkipNextFetch(false)
       setLoading(false)
       return
     }

     // Normal fetch logic...
   }, [dependencies, skipNextFetch])

   const handlePostSuccess = (newRecommendation) => {
     // 1. Update state immediately (optimistic)
     setReviews((prev) => [newRecommendation, ...prev])

     // 2. Skip next useEffect to prevent overwrite
     setSkipNextFetch(true)
   }
   ```

13. **Commented Out Features for Future Use**
   - Some features are temporarily commented out but may be re-enabled later
   - **ReactionButtons**: Commented out in ReviewCard.tsx (lines 14, 73-76)
   - **"„Åù„ÅÆ‰ªñ" input field**: Commented out in SourceSelector.tsx (lines 54-64)
   - **"„Åù„ÅÆ‰ªñ" validation**: Commented out in PostModal.tsx, route.ts files
   - Pattern: Use `/* TODO: Uncomment when ready */` for easy future activation

   **Example:**
   ```typescript
   // import ReactionButtons from '../Reaction/ReactionButtons' // TODO: Uncomment when ready

   {/* TODO: Uncomment when ready to use reaction feature */}
   {/* <ReactionButtons recommendationId={id} /> */}
   ```

14. **Edit Window Duration**
   - Current: 12 hours (reduced from original 24 hours)
   - Set in: `/api/recommendations/route.ts` line 203
   ```typescript
   const isEditableUntil = new Date(Date.now() + 12 * 60 * 60 * 1000) // 12 hours
   ```
   - Also check in: `/api/recommendations/[id]/route.ts` for edit window validation
   - Cookie expiration: Also 12 hours (`maxAge: 60 * 60 * 12`)

15. **N+1 Query Prevention with Global Caching**
   - Problem: Each review card making individual API calls to check edit permissions
   - **Root Cause**: Multiple component instances calling same API independently
   - Solution: Singleton pattern with module-level cache in `useEditPermission.ts`

   **Pattern:**
   ```typescript
   // Module-level cache (shared across all component instances)
   let cachedEditableIds: string[] = []
   let hasInitialized = false
   let cacheFetchPromise: Promise<string[]> | null = null

   async function fetchEditableIds(): Promise<string[]> {
     // Return cached data if already fetched
     if (hasInitialized) {
       return cachedEditableIds
     }

     // Return existing promise if fetch in progress
     if (cacheFetchPromise) {
       return cacheFetchPromise
     }

     // Single fetch for all components
     cacheFetchPromise = fetch('/api/recommendations/editable-list')
       .then(res => res.json())
       .then(data => {
         cachedEditableIds = data.editableIds || []
         hasInitialized = true
         cacheFetchPromise = null
         return cachedEditableIds
       })

     return cacheFetchPromise
   }
   ```

   **Benefits:**
   - 100 cards = 1 API request (instead of 100 requests)
   - Prevents API flooding in server logs
   - Shared cache across all component instances
   - Automatic deduplication of concurrent requests

16. **Parent-Child State Synchronization with Key Prop**
   - Problem: Child component with internal state doesn't update when parent passes new props
   - **Root Cause**: React doesn't re-render when prop reference changes if component is already mounted
   - Solution: Use `key` prop to force component remount when data changes

   **Pattern:**
   ```typescript
   // Parent component (HomeClient.tsx)
   <ReviewList
     key={reviews.length > 0 ? reviews[0]?.id : 'empty'}  // Force remount on data change
     initialReviews={reviews}
     onTagsChanged={() => setTagRefreshTrigger((prev) => prev + 1)}
   />

   // Child component (ReviewList.tsx)
   export default function ReviewList({ initialReviews = [] }: ReviewListProps) {
     const [reviews, setReviews] = useState<ExtendedRecommendation[]>(initialReviews)

     // Update internal state when parent passes new data
     useEffect(() => {
       setReviews(initialReviews)
       setPage(1)
       setHasMore(true)
     }, [initialReviews])
   }
   ```

   **When to use:**
   - Manual refresh functionality
   - Filter changes that should reset component state
   - Any parent state change that should force child re-initialization

17. **Manual Refresh Pattern (No Real-time Updates)**
   - Decision: Real-time updates disabled to save user data and prevent UI confusion
   - Pattern: Manual refresh button that fetches latest data from server

   **Implementation:**
   ```typescript
   // Parent component state
   const [refreshing, setRefreshing] = useState(false)

   // Reusable fetch function with manual refresh flag
   const fetchReviews = async (isManualRefresh = false) => {
     if (isManualRefresh) {
       setRefreshing(true)
     } else {
       setLoading(true)
     }

     try {
       const response = await fetch('/api/recommendations')
       const data = await response.json()
       setReviews(data.recommendations)
       if (isManualRefresh) {
         showToast('ÊúÄÊñ∞„ÅÆÊäïÁ®ø„ÇíË™≠„ÅøËæº„Åø„Åæ„Åó„Åü', 'success')
       }
     } finally {
       if (isManualRefresh) {
         setRefreshing(false)
       } else {
         setLoading(false)
       }
     }
   }

   // Refresh button
   <button onClick={() => fetchReviews(true)} disabled={refreshing}>
     <span className={refreshing ? 'animate-spin' : ''}>üîÑ</span>
     {refreshing ? 'Êõ¥Êñ∞‰∏≠...' : 'Êõ¥Êñ∞'}
   </button>
   ```

   **Why not real-time:**
   - Target users: 60+ age demographic, low data plans
   - Low posting frequency: Regional app, few posts per day
   - Better UX: Predictable interface, no sudden changes
   - Own posts still update immediately via optimistic updates

18. **Toast and Modal Replacement Pattern**
   - All `alert()` and `confirm()` calls replaced with custom components
   - Pattern: Use ToastProvider (global) + ConfirmModal (component-level)

   **Toast Usage:**
   ```typescript
   import { useToast } from '@/components/Toast/ToastProvider'

   const { showToast } = useToast()
   showToast('Êìç‰Ωú„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü', 'success')  // Auto-dismiss after 3s
   showToast('„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü', 'error')
   showToast('Âá¶ÁêÜ‰∏≠„Åß„Åô...', 'info')
   ```

   **Confirm Modal Usage:**
   ```typescript
   import ConfirmModal from '@/components/ConfirmModal/ConfirmModal'

   const [deleteConfirm, setDeleteConfirm] = useState<{ id: string; name: string } | null>(null)

   // Trigger confirmation
   const handleDelete = (id: string, name: string) => {
     setDeleteConfirm({ id, name })
   }

   // Actual delete function
   const confirmDelete = async () => {
     if (!deleteConfirm) return
     // ... perform delete
     setDeleteConfirm(null)
   }

   // Render modal
   <ConfirmModal
     isOpen={!!deleteConfirm}
     onClose={() => setDeleteConfirm(null)}
     onConfirm={confirmDelete}
     title="ÊäïÁ®ø„ÇíÂâäÈô§"
     message={`„Äå${deleteConfirm?.name}„Äç„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü`}
     confirmText="ÂâäÈô§„Åô„Çã"
     type="danger"
   />
   ```

   **Important:** Never use `alert()`, `confirm()`, or `prompt()` - always use custom components

19. **Admin Panel Long-Running Operations UI**
   - Problem: CSV import/export and bulk operations need clear visual feedback
   - Solution: Full-screen loading overlay with spinner and progress indicator

   **Pattern:**
   ```typescript
   // State management
   const [importing, setImporting] = useState(false)
   const [exporting, setExporting] = useState(false)
   const [deleting, setDeleting] = useState(false)

   // Operation handler
   const handleImportCSV = async (file: File) => {
     setImporting(true)
     try {
       const formData = new FormData()
       formData.append('file', file)
       const response = await fetch('/api/admin/import-facilities', {
         method: 'POST',
         body: formData,
       })
       const data = await response.json()
       if (data.success) {
         showToast(data.message, 'success')
       }
     } finally {
       setImporting(false)
     }
   }

   // Loading overlay
   {importing && (
     <div className="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center">
       <div className="bg-white rounded-lg shadow-washi p-8 max-w-md w-full mx-4">
         <div className="flex flex-col items-center">
           <div className="animate-spin rounded-full h-16 w-16 border-4 border-washi-green border-t-transparent mb-4"></div>
           <h3 className="text-xl font-bold text-gray-900 mb-2">CSVÂèñËæº‰∏≠...</h3>
           <p className="text-center text-gray-600 mb-4">
             ÊñΩË®≠„Éá„Éº„Çø„ÇíÂá¶ÁêÜ„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ<br />
             „Åó„Å∞„Çâ„Åè„ÅäÂæÖ„Å°„Åè„Å†„Åï„ÅÑ„ÄÇ
           </p>
           <div className="w-full bg-gray-200 rounded-full h-2 overflow-hidden">
             <div className="bg-washi-green h-full rounded-full animate-pulse" style={{ width: '100%' }}></div>
           </div>
           <p className="text-sm text-gray-500 mt-4">
             ‚Äª Âá¶ÁêÜ‰∏≠„ÅØÁîªÈù¢„ÇíÈñâ„Åò„Å™„ÅÑ„Åß„Åè„Å†„Åï„ÅÑ
           </p>
         </div>
       </div>
     </div>
   )}
   ```

   **Color coding by operation type:**
   - Import: Green spinner (washi-green)
   - Export: Blue spinner (blue-500)
   - Delete: Red spinner (red-500)

20. **CSV Import/Export Data Management**
   - CSV format must match database schema exactly (14 columns)
   - BOM (Byte Order Mark) required for Excel Japanese character support
   - All fields must be trimmed before validation to handle whitespace

   **CSV Import Validation:**
   ```typescript
   // Trim all fields before processing
   const fields = row.map(field => field.trim())

   // Required fields check
   if (!name || !area || !category) {
     errors.push(`Row ${i + 2}: ÂøÖÈ†à„Éï„Ç£„Éº„É´„Éâ„ÅåÁ©∫„Åß„Åô`)
     continue
   }
   ```

   **Insert vs Update logic:**
   - If CSV has `id` column with values ‚Üí UPDATE mode (requires existing records)
   - If CSV has `id` column empty ‚Üí INSERT mode (creates new records)
   - Best practice: Export from admin panel preserves IDs for safe updates

21. **Database Foreign Key Constraints (Critical)**
   - `recommendations.place_id` ‚Üí `places.id` with `ON DELETE CASCADE`
   - **‚ö†Ô∏è WARNING**: Deleting a facility will DELETE ALL recommendations for that facility
   - Safe operation: UPDATE facilities, not DELETE
   - To remove facilities from view: Set `is_verified = false` instead of DELETE

   **Safe facility data refresh pattern:**
   ```bash
   # 1. Export current data (preserves IDs)
   Admin Panel ‚Üí CSVÂá∫Âäõ

   # 2. Edit CSV (update names, addresses, etc.)
   # Keep existing IDs for updates, empty ID for new facilities

   # 3. Import back (updates existing + inserts new)
   Admin Panel ‚Üí CSVÂèñËæº
   ```

   **Dangerous operation (will delete user posts):**
   ```sql
   DELETE FROM places;  -- ‚ùå CASCADE deletes all recommendations!
   ```

   **Future improvement consideration:**
   ```sql
   -- Change CASCADE to SET NULL to preserve posts when facility deleted
   ALTER TABLE recommendations
   DROP CONSTRAINT recommendations_place_id_fkey,
   ADD CONSTRAINT recommendations_place_id_fkey
     FOREIGN KEY (place_id) REFERENCES places(id)
     ON DELETE SET NULL;
   ```

22. **UI/UX Layout and Scroll Management**
   - **Current Tag System**: 24 tags total (max 3 per post) after removing "ÈßÖËøë" and "ËªäÂøÖÈ†à" (see section 24 for details)
   - **Current Image System**: 1 image per post (reduced from 3 for storage optimization, see section 25)
   - **Header Mobile Display**: All buttons show icon-only on mobile (`hidden sm:inline` pattern)
   - **Default View**: List view is default on app load (`useState(false)` for showMap)
   - **Scroll Behavior**:
     - Map view: `overflow-hidden` prevents scrolling, mouse wheel controls map zoom
     - List view: Sticky header with scrollable content area
   - **Footer**: Fixed to bottom (`fixed bottom-0`) with `pb-28` padding on list content
   - **Post Modal**: Dynamic height based on facility suggestions (uses document flow, not absolute positioning)
     - Modal size: `max-w-2xl` width, `max-h-[95vh]` height, `p-2` outer padding
     - Facility search list grows with results, no fixed height constraint

   **Critical CSS patterns:**
   ```css
   /* globals.css */
   html {
     height: 100%;
     overflow: hidden;  /* Prevents html scroll */
   }

   /* layout.tsx */
   body {
     h-screen overflow-hidden  /* Fixed viewport height */
   }

   /* HomeClient.tsx - Conditional overflow */
   <main className={`h-screen w-screen flex ${showMap ? 'overflow-hidden' : ''}`}>
   <div className={`flex-1 flex flex-col ${showMap ? 'overflow-hidden' : ''}`}>

   /* List view - Scrollable container with sticky header */
   <div className="flex-1 overflow-y-auto min-h-0">
     <header className="sticky top-0 ...">
     <div className="px-4 py-6 pb-28">  /* pb-28 for footer clearance */

   /* FacilitySearchInput.tsx - Document flow (NOT absolute) */
   <div className="w-full mt-2 ...">  /* Grows modal naturally */
   ```

   **Layout hierarchy for scroll:**
   ```
   html (overflow: hidden)
   ‚îî‚îÄ‚îÄ body (h-screen overflow-hidden)
       ‚îî‚îÄ‚îÄ main (flex, conditional overflow-hidden)
           ‚îú‚îÄ‚îÄ Map view: overflow-hidden ‚Üí wheel controls zoom
           ‚îî‚îÄ‚îÄ List view: no overflow ‚Üí child handles scroll
               ‚îî‚îÄ‚îÄ div (overflow-y-auto) ‚Üí sticky header works here
   ```

23. **Content Security Policy (CSP) Configuration**
   - Problem: Browser warnings about missing worker-src and image quality settings
   - Solution: Configure CSP headers in `next.config.ts` and image quality settings

   **CSP Configuration (`next.config.ts`):**
   - `worker-src 'self' blob:` - Required for browser-image-compression library
   - `images.qualities: [75, 85, 100]` - Explicit quality levels for Next.js Image optimization

   **Important:** CSP warnings don't block functionality but should be addressed for:
   - Security policy clarity
   - Future Next.js compatibility
   - Clean console output

24. **Tag System and Color Coding**
   - **Total Tags**: 24 tags across 5 categories (max 3 per post)
   - **Category-Based Colors** (defined in `lib/formatters.ts`):
     - ÊñôÁêÜ„Ç∏„É£„É≥„É´ (6 tags) ‚Üí Red (`bg-red-100 text-red-700`)
     - Èõ∞Âõ≤Ê∞ó„ÉªÁâπÂæ¥ (7 tags) ‚Üí Blue (`bg-blue-100 text-blue-700`)
     - Ë™∞„Å®Ë°å„Åè (6 tags) ‚Üí Purple (`bg-purple-100 text-purple-700`)
     - „Ç¢„ÇØ„Çª„Çπ„ÉªË®≠ÂÇô (2 tags) ‚Üí Green (`bg-green-100 text-green-700`)
     - ÊôÇÈñìÂ∏Ø (3 tags) ‚Üí Orange (`bg-orange-100 text-orange-700`)

   **Pattern:**
   ```typescript
   // lib/formatters.ts - getTagColor function
   export function getTagColor(tag: string): string {
     // Check tag against predefined category arrays
     // Return consistent color per category
   }
   ```

   **Important:** If adding new tags, update both `TagSelector.tsx` and `formatters.ts`

25. **Image Upload Limits and Storage Management**
   - **Current Limit**: 1 image per post (reduced from 3 for storage optimization)
   - **Processing Pipeline**:
     - Client: browser-image-compression (max 1MB, 1920px)
     - Server: sharp (resize to 1200px, WebP at 80% quality)
     - Storage: Supabase Storage (recommendations-images bucket)

   **Validation Points:**
   - `ImageUpload.tsx`: `maxImages={1}` default
   - `PostModal.tsx`: Pass `maxImages={1}` to ImageUpload
   - `EditModal.tsx`: Single image display (no grid)
   - API validation: Both POST and PATCH routes check `images.length > 1`

   **Storage Estimates:**
   - Average image size: 100-300KB (WebP compressed)
   - 1,000 posts √ó 1 image √ó 200KB = ~200MB
   - 5,000 posts √ó 1 image √ó 200KB = ~1GB (free plan limit)

   **Important:** Existing posts with 3 images remain intact (ReviewImage.tsx handles multiple images)
